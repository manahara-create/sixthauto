// src/services/reportServices.js
import { supabase } from './supabase';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import DatabaseService from './databaseService';
import dayjs from 'dayjs';

export class ReportService {
  static async generatePDFReport(reportData, options = {}) {
    try {
      const doc = new jsPDF();
      const {
        title = 'Report',
        subtitle = '',
        headers = [],
        data = [],
        summary = null,
        footer = null,
      } = options;

      // Set document properties
      doc.setProperties({
        title: title,
        subject: subtitle,
        author: 'HR System',
        creator: 'HR System'
      });

      // Title
      doc.setFontSize(20);
      doc.text(title, 105, 15, { align: 'center' });
      
      if (subtitle) {
        doc.setFontSize(12);
        doc.text(subtitle, 105, 25, { align: 'center' });
      }

      // Generated info
      doc.setFontSize(10);
      doc.text(`Generated on: ${dayjs().format('MMMM D, YYYY HH:mm')}`, 14, 35);
      
      if (reportData.generatedBy) {
        doc.text(`Generated by: ${reportData.generatedBy}`, 14, 42);
      }

      // Summary section
      let startY = 50;
      if (summary) {
        doc.setFontSize(12);
        doc.text('Summary:', 14, startY);
        doc.setFontSize(10);
        
        let y = startY + 6;
        Object.entries(summary).forEach(([key, value]) => {
          doc.text(`${key}: ${value}`, 14, y);
          y += 6;
        });
        startY = y + 4;
      }

      // Table
      if (headers.length && data.length) {
        doc.autoTable({
          startY,
          head: [headers],
          body: data,
          theme: 'grid',
          styles: { fontSize: 8 },
          headStyles: { fillColor: [41, 128, 185] }
        });
      } else {
        doc.text('No data available', 14, startY);
      }

      // Add page numbers
      const pageCount = doc.internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.text(
          `Page ${i} of ${pageCount}`,
          doc.internal.pageSize.width / 2,
          doc.internal.pageSize.height - 10,
          { align: 'center' }
        );
      }

      return doc;
    } catch (error) {
      console.error('Error generating PDF report:', error);
      throw error;
    }
  }

  static async generateSalaryReport(filters = {}) {
    try {
      const salaries = await DatabaseService.getSalaries(filters);
      
      const headers = ['Employee', 'Department', 'Basic Salary', 'OT Pay', 'Bonus', 'Total Salary', 'Date'];
      const data = salaries.map(salary => [
        `${salary.employee?.full_name || ''}`.trim() || 'N/A',
        salary.employee?.department || 'N/A',
        `$${(salary.basicsalary || 0).toLocaleString()}`,
        `$${(salary.otpay || 0).toLocaleString()}`,
        `$${(salary.bonuspay || 0).toLocaleString()}`,
        `$${(salary.totalsalary || 0).toLocaleString()}`,
        salary.salarydate ? dayjs(salary.salarydate).format('MMM D, YYYY') : 'N/A'
      ]);

      const totalSalary = salaries.reduce((sum, s) => sum + (s.totalsalary || 0), 0);

      const doc = await this.generatePDFReport({ 
        generatedBy: filters.employeeId ? 'Employee' : 'Admin' 
      }, {
        title: 'Salary Report',
        subtitle: filters.month ? `Month: ${filters.month}` : 'All Time',
        headers,
        data,
        summary: {
          'Total Records': salaries.length,
          'Total Payout': `$${totalSalary.toLocaleString()}`,
          'Average Salary': `$${Math.round(totalSalary / (salaries.length || 1)).toLocaleString()}`
        }
      });

      return doc;
    } catch (error) {
      console.error('Error generating salary report:', error);
      throw error;
    }
  }

  static async generateAttendanceReport(filters = {}) {
    try {
      const attendance = await DatabaseService.getAttendance(filters);
      
      const headers = ['Employee', 'Date', 'Punch In', 'Punch Out', 'Status', 'Working Hours'];
      const data = attendance.map(record => {
        let workingHours = 'N/A';
        if (record.intime && record.outtime) {
          try {
            const inTime = dayjs(record.intime, 'HH:mm:ss');
            const outTime = dayjs(record.outtime, 'HH:mm:ss');
            const hours = outTime.diff(inTime, 'hour', true);
            workingHours = `${hours.toFixed(2)}h`;
          } catch (e) {
            console.warn('Error calculating working hours:', e);
          }
        }

        return [
          `${record.employee?.full_name || ''}`.trim() || 'N/A',
          record.date ? dayjs(record.date).format('MMM D, YYYY') : 'N/A',
          record.intime || 'N/A',
          record.outtime || 'N/A',
          record.status || 'N/A',
          workingHours
        ];
      });

      const present = attendance.filter(a => a.status === 'Present').length;
      const absent = attendance.filter(a => a.status === 'Absent').length;
      const late = attendance.filter(a => a.status === 'Late').length;

      const doc = await this.generatePDFReport({}, {
        title: 'Attendance Report',
        subtitle: filters.month ? `Month: ${filters.month}` : 'All Time',
        headers,
        data,
        summary: {
          'Total Days': attendance.length,
          'Present': present,
          'Absent': absent,
          'Late': late
        }
      });

      return doc;
    } catch (error) {
      console.error('Error generating attendance report:', error);
      throw error;
    }
  }

  static async generateLeaveReport(filters = {}) {
    try {
      const leaves = await DatabaseService.getLeaves(filters);
      
      const headers = ['Employee', 'Type', 'From', 'To', 'Days', 'Status'];
      const data = leaves.map(leave => [
        `${leave.employee?.full_name || ''}`.trim() || 'N/A',
        leave.leavetype?.leavetype || 'N/A',
        leave.leavefromdate ? dayjs(leave.leavefromdate).format('MMM D, YYYY') : 'N/A',
        leave.leavetodate ? dayjs(leave.leavetodate).format('MMM D, YYYY') : 'N/A',
        leave.duration || leave.noofdays || 'N/A',
        leave.leavestatus || 'N/A'
      ]);

      const statusCount = leaves.reduce((acc, leave) => {
        const status = leave.leavestatus || 'Unknown';
        acc[status] = (acc[status] || 0) + 1;
        return acc;
      }, {});

      const doc = await this.generatePDFReport({}, {
        title: 'Leave Report',
        subtitle: filters.month ? `Month: ${filters.month}` : 'All Time',
        headers,
        data,
        summary: {
          'Total Leaves': leaves.length,
          'Pending': statusCount.pending || 0,
          'Approved': statusCount.approved || 0,
          'Rejected': statusCount.rejected || 0
        }
      });

      return doc;
    } catch (error) {
      console.error('Error generating leave report:', error);
      throw error;
    }
  }

  static async generateEmployeeReport(filters = {}) {
    try {
      const employees = await DatabaseService.getEmployees(filters);
      
      const headers = ['Employee ID', 'Name', 'Email', 'Department', 'Role', 'Status', 'Join Date'];
      const data = employees.map(emp => [
        emp.empid || 'N/A',
        `${emp.full_name || ''}`.trim() || 'N/A',
        emp.email || 'N/A',
        emp.role || 'N/A',
        emp.status || (emp.is_active ? 'Active' : 'Inactive'),
        emp.created_at ? dayjs(emp.created_at).format('MMM D, YYYY') : 'N/A'
      ]);

      const deptCount = employees.reduce((acc, e) => {
        const dept = e.department || 'Unknown';
        acc[dept] = (acc[dept] || 0) + 1;
        return acc;
      }, {});

      const summary = {
        'Total Employees': employees.length,
        'Active Employees': employees.filter(e => e.is_active).length,
        'Departments': Object.keys(deptCount).length,
        ...deptCount
      };

      const doc = await this.generatePDFReport({}, {
        title: 'Employee Report',
        headers,
        data,
        summary
      });

      return doc;
    } catch (error) {
      console.error('Error generating employee report:', error);
      throw error;
    }
  }

  static downloadPDF(doc, filename) {
    try {
      const timestamp = dayjs().format('YYYYMMDD_HHmmss');
      doc.save(`${filename}_${timestamp}.pdf`);
    } catch (error) {
      console.error('Error downloading PDF:', error);
      throw error;
    }
  }

  static printPDF(doc) {
    try {
      doc.autoPrint();
      const blob = doc.output('blob');
      const url = URL.createObjectURL(blob);
      const printWindow = window.open(url);
      
      if (printWindow) {
        printWindow.onload = () => {
          printWindow.print();
        };
      } else {
        this.downloadPDF(doc, 'report');
      }
    } catch (error) {
      console.error('Error printing PDF:', error);
      this.downloadPDF(doc, 'report');
    }
  }
}

export default ReportService;